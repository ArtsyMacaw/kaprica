#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <getopt.h>
#include <gtk/gtk.h>
#include "clipboard.h"
#include "database.h"
#include "xmalloc.h"
#include "config.h" /* Generated by meson */

enum defaults
{
    NUMBER_OF_SOURCES = 20,
    WINDOW_WIDTH = 340,
    WINDOW_HEIGHT = 430
};

struct config
{
    gboolean no_csd;
    char *database;
    char *style;
    bool version;
};

static struct config options = {
    .no_csd = FALSE, .database = NULL, .style = NULL, .version = FALSE};

GOptionEntry entries[] = {{"no-csd", 'n', 0, G_OPTION_ARG_NONE, &options.no_csd,
                           "Disable client-side decorations", NULL},
                          {"database", 'D', 0, G_OPTION_ARG_STRING,
                           &options.database,
                           "Specify the path to the history database", NULL},
                          {"style", 's', 0, G_OPTION_ARG_STRING, &options.style,
                           "Specify the path to the CSS style sheet", NULL},
                          {"version", 'v', 0, G_OPTION_ARG_NONE,
                           &options.version, "Show version number", NULL},
                          {NULL}};

// TODO: Convert UI interface into a blueprint file
struct Widgets
{
    /* Main window */
    GtkWidget *window;
    GtkWidget *back_list;
    GtkWidget *header_bar;
    GtkWidget *close_window;
    GtkWidget *visible;
    /* Search */
    GtkWidget *search_bar;
    GtkWidget *scrolled_window_search;
    GtkWidget *search_list;
    GtkWidget *no_match;
    /* Entry */
    GtkWidget *scrolled_window_entry;
    GtkWidget *entry_list;
    GtkWidget *no_entry;
    /* Clear all */
    GtkWidget *clear_all;
    GtkWidget *confirm_vbox;
    GtkWidget *confirm_label;
    GtkWidget *confirm_hbox;
    GtkWidget *confirm_yes;
    GtkWidget *confirm_no;
    /* Database */
    sqlite3 *db;
    int64_t data_version;
};

/* Used to pass around data throughout the entire search process */
struct search_data
{
    char *text;
    uint32_t total_sources;
    uint32_t found;
    uint32_t offset;
    int64_t *ids;
    enum search_type type;
    struct Widgets *widgets;
    GtkWidget **buttons;
};

/* Packs the id of the entry and widgets into a struct to pass to the
 * callback */
struct id_data
{
    gpointer id;
    struct Widgets *widgets;
};

/* Used to load more entries into the list when the user scrolls */
struct load_data
{
    int64_t *ids;
    uint32_t found;
    uint32_t offset;
    struct Widgets *widgets;
};

static void clicked(GtkWidget *button, gpointer user_data)
{
    clipboard *clip = clip_init();
    struct id_data *data = user_data;
    int64_t t = GPOINTER_TO_UINT(data->id);
    database_get_entry(data->widgets->db, t, clip->selection_source);
    database_close(data->widgets->db);
    clip_set_selection(clip);

    pid_t pid = fork();
    if (pid < 0)
    {
        fprintf(stderr, "Failed to fork\n");
        exit(EXIT_FAILURE);
    }
    else if (pid == 0)
    {
        while (wl_display_dispatch(clip->display) >= 0)
            ;
        clip_destroy(clip);
    }
}

/* Passes the signal to clicked() */
static void row_activated(GtkListBox *box, GtkListBoxRow *row,
                          gpointer user_data)
{
    GtkWidget *button_box = gtk_list_box_row_get_child(row);
    GtkWidget *button = gtk_widget_get_first_child(button_box);

    g_signal_emit_by_name(button, "clicked");
}

/* When the user presses enter in the search bar, copy the first entry shown */
static void copy_first_row(GtkSearchEntry *search, gpointer user_data)
{
    struct Widgets *widgets = user_data;
    if (widgets->visible == widgets->no_match ||
        widgets->visible == widgets->no_entry)
    {
        return;
    }

    GtkWidget *scrolled_window = widgets->visible;
    GtkWidget *viewport =
        gtk_scrolled_window_get_child(GTK_SCROLLED_WINDOW(scrolled_window));
    GtkWidget *list = gtk_viewport_get_child(GTK_VIEWPORT(viewport));
    GtkListBoxRow *row = gtk_list_box_get_row_at_index(GTK_LIST_BOX(list), 0);

    row_activated(GTK_LIST_BOX(list), row, NULL);
}

static void delete_entry(GtkWidget *button, gpointer user_data)
{
    struct id_data *data = user_data;
    int64_t t = GPOINTER_TO_UINT(data->id);

    GtkWidget *button_box = gtk_widget_get_parent(button);
    GtkWidget *ListBoxRow = gtk_widget_get_parent(button_box);
    GtkWidget *list = gtk_widget_get_parent(ListBoxRow);

    database_delete_entry(data->widgets->db, t);
    gtk_list_box_remove(GTK_LIST_BOX(list), ListBoxRow);
}

static GtkWidget *create_button_box()
{
    GtkWidget *button_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_box_set_homogeneous(GTK_BOX(button_box), FALSE);
    gtk_widget_set_halign(button_box, GTK_ALIGN_FILL);
    gtk_widget_set_valign(button_box, GTK_ALIGN_FILL);
    gtk_widget_set_hexpand(button_box, TRUE);
    gtk_widget_set_vexpand(button_box, TRUE);

    return button_box;
}

static GtkWidget *create_entry_button(int64_t id, struct Widgets *widgets)
{
    GtkWidget *button;
    void *thumbnail = NULL, *snippet = NULL;
    size_t len = 0;

    thumbnail = database_get_thumbnail(widgets->db, id, &len);
    if (len)
    {
        /* Convert thumbnail into a gbytes structure so it can be turned into a
         * texture */
        GBytes *pix_array = g_bytes_new(thumbnail, len);
        GdkTexture *texture = gdk_texture_new_from_bytes(pix_array, NULL);
        GtkWidget *image =
            gtk_picture_new_for_paintable(GDK_PAINTABLE(texture));

        g_bytes_unref(pix_array);
        free(thumbnail);

        /* A lot of formatting code to left align the image and fill to fit the
         * button */
        gtk_widget_set_halign(image, GTK_ALIGN_START);
        gtk_widget_set_valign(image, GTK_ALIGN_FILL);
        gtk_widget_set_hexpand(image, TRUE);
        gtk_widget_set_vexpand(image, TRUE);
        gtk_picture_set_can_shrink(GTK_PICTURE(image), TRUE);
        gtk_picture_set_content_fit(GTK_PICTURE(image),
                                    GTK_CONTENT_FIT_CONTAIN);
        gtk_widget_set_size_request(image, 250, 80);
        gtk_widget_set_margin_start(image, 0);
        gtk_widget_set_margin_end(image, 0);
        gtk_widget_set_margin_top(image, 0);
        gtk_widget_set_margin_bottom(image, 0);

        button = gtk_button_new();
        gtk_button_set_child(GTK_BUTTON(button), image);
    }
    else
    {
        snippet = database_get_snippet(widgets->db, id);
        button = gtk_button_new_with_label(snippet);
        GtkWidget *label = gtk_button_get_child(GTK_BUTTON(button));

        free(snippet);

        /* Set the label to wrap and left align */
        gtk_label_set_wrap(GTK_LABEL(label), TRUE);
        gtk_label_set_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);
        gtk_label_set_xalign(GTK_LABEL(label), 0);
    }

    /* Formatting code to make the button look nice */
    gtk_button_set_can_shrink(GTK_BUTTON(button), FALSE);
    gtk_button_set_has_frame(GTK_BUTTON(button), FALSE);
    gtk_widget_set_halign(button, GTK_ALIGN_FILL);
    gtk_widget_set_hexpand(button, TRUE);

    struct id_data *data = xmalloc(sizeof(struct id_data));
    data->id = GUINT_TO_POINTER(id);
    data->widgets = widgets;

    /* Copy the content and exit */
    g_signal_connect(button, "clicked", G_CALLBACK(clicked), data);
    g_signal_connect_swapped(button, "clicked", G_CALLBACK(gtk_window_destroy),
                             GTK_WINDOW(widgets->window));

    return button;
}

static GtkWidget *create_delete_button(int64_t id, struct Widgets *widgets)
{
    GtkWidget *button = gtk_button_new_from_icon_name("edit-delete");

    /* More formatting */
    gtk_button_set_has_frame(GTK_BUTTON(button), FALSE);
    gtk_widget_set_halign(button, GTK_ALIGN_END);
    gtk_widget_set_valign(button, GTK_ALIGN_FILL);

    struct id_data *data = xmalloc(sizeof(struct id_data));
    data->id = GUINT_TO_POINTER(id);
    data->widgets = widgets;

    g_signal_connect(button, "clicked", G_CALLBACK(delete_entry), data);

    return button;
}

static GtkWidget *create_button(int64_t id, struct Widgets *widgets)
{
    GtkWidget *button_box = create_button_box();
    GtkWidget *button = create_entry_button(id, widgets);
    GtkWidget *delete = create_delete_button(id, widgets);

    /* Makes the buttons not focusable so tabbing and shift-tabbing only
     * focuses the ListBoxRows */
    gtk_widget_set_can_focus(delete, FALSE);
    gtk_widget_set_can_focus(button, FALSE);
    gtk_widget_set_can_focus(button_box, FALSE);

    gtk_box_prepend(GTK_BOX(button_box), button);
    gtk_box_append(GTK_BOX(button_box), delete);

    return button_box;
}

static void swap_visible(struct Widgets *widgets, GtkWidget *list)
{
    gtk_widget_set_visible(widgets->visible, FALSE);
    gtk_widget_set_visible(list, TRUE);
    widgets->visible = list;
}

static void load_more_entries(GtkScrolledWindow *scrolled_window,
                              GtkPositionType pos, gpointer user_data)
{
    GtkWidget *viewport = gtk_scrolled_window_get_child(scrolled_window);
    GtkWidget *list = gtk_viewport_get_child(GTK_VIEWPORT(viewport));

    struct load_data *load = user_data;
    struct Widgets *widgets = load->widgets;
    uint32_t offset = load->offset;

    for (int i = offset; i < load->found && i < (NUMBER_OF_SOURCES + offset);
         i++)
    {
        GtkWidget *button = create_button(load->ids[i], widgets);
        gtk_list_box_insert(GTK_LIST_BOX(list), button, -1);
        load->offset += 1;
    }
}

static gboolean find_search_result_finish(GObject *source_object,
                                          GAsyncResult *res, gpointer user_data)
{
    GTask *task = G_TASK(res);
    struct search_data *data = g_task_propagate_pointer(task, NULL);
    if (data == NULL) /* Search was cancelled */
    {
        return G_SOURCE_REMOVE;
    }

    struct Widgets *widgets = user_data;
    GtkWidget *scrolled_window = widgets->scrolled_window_search;
    gtk_list_box_remove_all(GTK_LIST_BOX(widgets->search_list));

    for (int i = 0; i < data->found && i < NUMBER_OF_SOURCES; i++)
    {
        gtk_list_box_insert(GTK_LIST_BOX(widgets->search_list),
                            data->buttons[i], -1);
        data->offset += 1;
    }

    if (data->found)
    {
        swap_visible(data->widgets, data->widgets->scrolled_window_search);
    }
    else
    {
        swap_visible(data->widgets, data->widgets->no_match);
    }

    g_signal_handlers_disconnect_by_func(scrolled_window,
                                         G_CALLBACK(load_more_entries), NULL);

    struct load_data *load = xmalloc(sizeof(struct load_data));
    load->ids = xmalloc(sizeof(int64_t) * data->found);
    for (int i = 0; i < data->found; i++)
    {
        load->ids[i] = data->ids[i];
    }
    load->found = data->found;
    load->offset = data->offset;
    load->widgets = widgets;

    g_signal_connect(scrolled_window, "edge-reached",
                     G_CALLBACK(load_more_entries), load);

    return G_SOURCE_REMOVE;
}

static void find_search_result_async(GTask *task, gpointer task_data,
                                     GCancellable *cancellable)
{
    struct search_data *data = g_task_get_task_data(task);

    data->found = database_find_matching_entries(
        data->widgets->db, (void *)data->text, strlen(data->text),
        data->total_sources, data->ids, data->type);
    data->buttons = xmalloc(sizeof(GtkWidget *) * data->found);

    for (int i = 0; i < data->found && i < NUMBER_OF_SOURCES; i++)
    {
        data->buttons[i] = create_button(data->ids[i], data->widgets);
    }

    g_task_return_pointer(task, data, NULL);
}

static void search_database(GtkSearchEntry *search_bar, gpointer user_data)
{
    struct Widgets *widgets = user_data;
    GtkWidget *scrolled_window = widgets->scrolled_window_search;
    struct search_data *search = xmalloc(sizeof(struct search_data));
    const char *text = gtk_editable_get_text(GTK_EDITABLE(search_bar));

    if (!strlen(text))
    {
        swap_visible(widgets, widgets->scrolled_window_entry);
        return;
    }

    if (strncmp(text, "type:", strlen("type:")) == 0)
    {
        search->type = MIME_TYPE;
        text += strlen("type:");
    }
    else if (strncmp(text, "glob:", strlen("glob:")) == 0)
    {
        search->type = GLOB;
        text += strlen("glob:");
    }
    else
    {
        search->type = CONTENT;
    }

    search->text = xstrdup(text);
    search->offset = 0;
    search->found = 0;
    search->buttons = NULL;
    search->total_sources = database_get_total_entries(widgets->db);
    search->widgets = widgets;
    search->ids = xmalloc(sizeof(int64_t) * search->total_sources);

    /* Cancel the current search if it's still running */
    g_cancellable_cancel(g_cancellable_get_current());

    GCancellable *cancel_search = g_cancellable_new();
    g_cancellable_push_current(cancel_search);
    GTask *task =
        g_task_new(G_OBJECT(scrolled_window), cancel_search,
                   (GAsyncReadyCallback)find_search_result_finish, widgets);

    g_task_set_task_data(task, search, NULL);
    g_task_set_return_on_cancel(task, TRUE);
    g_task_run_in_thread(task, (GTaskThreadFunc)find_search_result_async);
}

static void confirm_clear_all(GtkWidget *button, gpointer user_data)
{
    struct Widgets *widgets = user_data;

    /* Make close button stick to the right */
    gtk_widget_set_hexpand(widgets->close_window, TRUE);

    gtk_widget_set_visible(widgets->clear_all, FALSE);
    gtk_widget_set_visible(widgets->visible, FALSE);
    gtk_widget_set_visible(widgets->search_bar, FALSE);
    gtk_widget_set_visible(widgets->confirm_vbox, TRUE);
}

static void clear_all_no(GtkWidget *button, gpointer user_data)
{
    struct Widgets *widgets = user_data;

    gtk_widget_set_hexpand(widgets->close_window, FALSE);

    gtk_widget_set_visible(widgets->search_bar, TRUE);
    gtk_widget_set_visible(widgets->visible, TRUE);
    gtk_widget_set_visible(widgets->clear_all, TRUE);
    gtk_widget_set_visible(widgets->confirm_vbox, FALSE);
}

static void clear_all_yes(GtkWidget *button, gpointer user_data)
{
    struct Widgets *widgets = user_data;

    // TODO: implement database_clear_all(db);
    gtk_list_box_remove_all(GTK_LIST_BOX(widgets->entry_list));

    gtk_widget_set_hexpand(widgets->close_window, FALSE);

    gtk_widget_set_visible(widgets->clear_all, TRUE);
    gtk_widget_set_visible(widgets->no_entry, TRUE);
    gtk_widget_set_visible(widgets->search_bar, TRUE);
    gtk_widget_set_visible(widgets->confirm_vbox, FALSE);

    widgets->visible = widgets->no_entry;
}

static gboolean load_entries_finish(GObject *source_object, GAsyncResult *res,
                                    gpointer user_data)
{
    GTask *task = G_TASK(res);
    GtkWidget **buttons = g_task_propagate_pointer(task, NULL);
    const uint32_t found = *(uint32_t *)user_data;
    GtkWidget *entry_list = GTK_WIDGET(source_object);

    for (int i = 0; i < found && i < NUMBER_OF_SOURCES; i++)
    {
        gtk_list_box_insert(GTK_LIST_BOX(entry_list), buttons[i], -1);
    }

    return G_SOURCE_REMOVE;
}

static void load_entries_async(GTask *task, gpointer task_data,
                               GCancellable *cancellable)
{
    struct load_data *data = g_task_get_task_data(task);
    struct Widgets *widgets = data->widgets;
    GtkWidget **buttons = xmalloc(sizeof(GtkWidget *) * NUMBER_OF_SOURCES);
    database_get_latest_entries(widgets->db, data->found, data->offset,
                                data->ids);

    for (int i = 0; i < data->found && i < NUMBER_OF_SOURCES; i++)
    {
        buttons[i] = create_button(data->ids[i], widgets);
        data->offset += 1;
    }

    g_task_return_pointer(task, buttons, NULL);
}

static char *find_style_path()
{
    char *style_path = NULL;
    const char *xdg_config_home = getenv("XDG_CONFIG_HOME");
    if (xdg_config_home)
    {
        style_path =
            xmalloc(strlen(xdg_config_home) + strlen("/kaprica/style.css") + 1);
        strcpy(style_path, xdg_config_home);
        strcat(style_path, "/kaprica/style.css");
    }
    else
    {
        const char *home = getenv("HOME");
        style_path =
            xmalloc(strlen(home) + strlen("/.config/kaprica/style.css") + 1);
        strcpy(style_path, home);
        strcat(style_path, "/.config/kaprica/style.css");
    }

    return (access(style_path, F_OK) == 0) ? style_path : NULL;
}

static void activate(GtkApplication *app, gpointer user_data)
{
    if (options.version)
    {
        printf("Kaprica %s\n", PROJECT_VERSION);
        exit(EXIT_SUCCESS);
    }

    /* Create the main window */
    struct Widgets *widgets = xmalloc(sizeof(struct Widgets));
    widgets->window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(widgets->window), "kaprica");
    gtk_window_set_default_size(GTK_WINDOW(widgets->window), WINDOW_WIDTH,
                                WINDOW_HEIGHT);
    widgets->back_list = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);

    /* Load the CSS style sheet if it exists */
    options.style = (options.style != NULL) ? options.style : find_style_path();
    if (options.style)
    {
        GtkCssProvider *provider = gtk_css_provider_new();
        gtk_css_provider_load_from_path(provider, options.style);
        gtk_style_context_add_provider_for_display(
            gdk_display_get_default(), GTK_STYLE_PROVIDER(provider),
            GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
    }

    /* Setup global ALT+ESC shortcut to close the window */
    GtkShortcutTrigger *trigger =
        gtk_keyval_trigger_new(GDK_KEY_Escape, GDK_ALT_MASK);
    GtkShortcutAction *action = gtk_callback_action_new(
        (GtkShortcutFunc)gtk_window_destroy, widgets->window, NULL);
    GtkShortcut *shortcut = gtk_shortcut_new(trigger, action);
    GtkEventController *controller = gtk_shortcut_controller_new();
    gtk_shortcut_controller_set_scope(GTK_SHORTCUT_CONTROLLER(controller),
                                      GTK_SHORTCUT_SCOPE_GLOBAL);
    gtk_shortcut_controller_add_shortcut(GTK_SHORTCUT_CONTROLLER(controller),
                                         shortcut);
    gtk_widget_add_controller(widgets->window, controller);

    /* Open a connection to the database */
    widgets->db = database_open(options.database);
    if (!widgets->db)
    {
        fprintf(stderr, "Could not locate history database\n");
        exit(EXIT_FAILURE);
    }
    uint32_t total_sources = database_get_total_entries(widgets->db);

    /* Setup list of all entries in the database */
    widgets->scrolled_window_entry = gtk_scrolled_window_new();
    widgets->entry_list = gtk_list_box_new();
    widgets->no_entry = gtk_label_new("No entries yet...");

    struct load_data *load = xmalloc(sizeof(struct load_data));
    load->ids = xmalloc(sizeof(int64_t) * total_sources);
    load->found = total_sources;
    load->offset = 0;
    load->widgets = widgets;

    /* Load initial entries */
    GTask *task =
        g_task_new(G_OBJECT(widgets->entry_list), NULL,
                   (GAsyncReadyCallback)load_entries_finish, &load->found);
    g_task_set_priority(task, G_PRIORITY_LOW);
    g_task_set_task_data(task, load, NULL);
    g_task_run_in_thread(task, (GTaskThreadFunc)load_entries_async);

    gtk_scrolled_window_set_child(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_entry),
        widgets->entry_list);
    gtk_scrolled_window_set_max_content_width(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_entry), WINDOW_WIDTH);
    gtk_scrolled_window_set_propagate_natural_width(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_entry), TRUE);
    gtk_scrolled_window_set_policy(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_entry), GTK_POLICY_NEVER,
        GTK_POLICY_AUTOMATIC);
    g_signal_connect(widgets->scrolled_window_entry, "edge-reached",
                     G_CALLBACK(load_more_entries), load);
    g_signal_connect(widgets->entry_list, "row-activated",
                     G_CALLBACK(row_activated), NULL);

    /* Setup searching */
    widgets->header_bar = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    widgets->close_window = gtk_button_new_from_icon_name("window-close");
    widgets->search_bar = gtk_search_entry_new();
    widgets->search_list = gtk_list_box_new();
    widgets->scrolled_window_search = gtk_scrolled_window_new();
    widgets->no_match = gtk_label_new("No matches found...");

    gtk_box_prepend(GTK_BOX(widgets->header_bar), widgets->search_bar);
    gtk_box_append(GTK_BOX(widgets->header_bar), widgets->close_window);
    gtk_button_set_has_frame(GTK_BUTTON(widgets->close_window), FALSE);
    gtk_widget_set_can_focus(widgets->close_window, FALSE);

    gtk_search_entry_set_placeholder_text(GTK_SEARCH_ENTRY(widgets->search_bar),
                                          "Search...");
    gtk_search_entry_set_search_delay(GTK_SEARCH_ENTRY(widgets->search_bar),
                                      300);
    gtk_scrolled_window_set_child(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_search),
        widgets->search_list);
    gtk_scrolled_window_set_max_content_width(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_search), WINDOW_WIDTH);
    gtk_scrolled_window_set_propagate_natural_width(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_search), TRUE);
    gtk_scrolled_window_set_policy(
        GTK_SCROLLED_WINDOW(widgets->scrolled_window_search), GTK_POLICY_NEVER,
        GTK_POLICY_AUTOMATIC);

    g_signal_connect(widgets->search_bar, "search-changed",
                     G_CALLBACK(search_database), widgets);
    g_signal_connect(widgets->search_list, "row-activated",
                     G_CALLBACK(row_activated), NULL);
    g_signal_connect_swapped(widgets->close_window, "clicked",
                             G_CALLBACK(gtk_window_destroy),
                             GTK_WINDOW(widgets->window));
    g_signal_connect(widgets->search_bar, "activate",
                     G_CALLBACK(copy_first_row), widgets);

    /* Setup clear all */
    widgets->clear_all = gtk_button_new_with_label("Clear All");
    widgets->confirm_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    widgets->confirm_label =
        gtk_label_new("Are you sure you want to delete everything?");
    widgets->confirm_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    widgets->confirm_yes = gtk_button_new_with_label("Yes");
    widgets->confirm_no = gtk_button_new_with_label("No");

    gtk_button_set_has_frame(GTK_BUTTON(widgets->confirm_no), FALSE);
    gtk_button_set_has_frame(GTK_BUTTON(widgets->confirm_yes), FALSE);

    g_signal_connect(widgets->clear_all, "clicked",
                     G_CALLBACK(confirm_clear_all), widgets);
    g_signal_connect(widgets->confirm_no, "clicked", G_CALLBACK(clear_all_no),
                     widgets);
    g_signal_connect(widgets->confirm_yes, "clicked", G_CALLBACK(clear_all_yes),
                     widgets);

    gtk_box_prepend(GTK_BOX(widgets->confirm_vbox), widgets->confirm_label);
    gtk_box_append(GTK_BOX(widgets->confirm_vbox), widgets->confirm_hbox);
    gtk_box_append(GTK_BOX(widgets->confirm_hbox), widgets->confirm_yes);
    gtk_box_append(GTK_BOX(widgets->confirm_hbox), widgets->confirm_no);

    /* Wow, more formatting code */
    gtk_widget_set_hexpand(widgets->entry_list, TRUE);
    gtk_widget_set_vexpand(widgets->entry_list, TRUE);
    gtk_widget_set_hexpand(widgets->search_list, TRUE);
    gtk_widget_set_vexpand(widgets->search_list, TRUE);
    gtk_widget_set_hexpand(widgets->no_entry, TRUE);
    gtk_widget_set_vexpand(widgets->no_entry, TRUE);
    gtk_widget_set_hexpand(widgets->no_match, TRUE);
    gtk_widget_set_vexpand(widgets->no_match, TRUE);
    gtk_widget_set_hexpand(widgets->confirm_label, TRUE);
    gtk_widget_set_vexpand(widgets->confirm_label, TRUE);
    gtk_widget_set_hexpand(widgets->confirm_hbox, TRUE);
    gtk_widget_set_vexpand(widgets->confirm_hbox, TRUE);
    gtk_widget_set_hexpand(widgets->confirm_yes, TRUE);
    gtk_widget_set_vexpand(widgets->confirm_yes, TRUE);
    gtk_widget_set_hexpand(widgets->confirm_no, TRUE);
    gtk_widget_set_vexpand(widgets->confirm_no, TRUE);
    gtk_widget_set_hexpand(widgets->search_bar, TRUE);
    gtk_widget_set_hexpand(widgets->header_bar, TRUE);
    gtk_widget_set_valign(widgets->scrolled_window_entry, GTK_ALIGN_FILL);
    gtk_widget_set_valign(widgets->scrolled_window_search, GTK_ALIGN_FILL);
    gtk_widget_set_valign(widgets->back_list, GTK_ALIGN_FILL);
    gtk_widget_set_valign(widgets->no_entry, GTK_ALIGN_FILL);
    gtk_widget_set_valign(widgets->search_bar, GTK_ALIGN_START);
    gtk_widget_set_halign(widgets->search_bar, GTK_ALIGN_FILL);
    gtk_widget_set_halign(widgets->header_bar, GTK_ALIGN_FILL);
    gtk_widget_set_halign(widgets->close_window, GTK_ALIGN_END);
    gtk_widget_set_valign(widgets->clear_all, GTK_ALIGN_END);
    gtk_box_set_homogeneous(GTK_BOX(widgets->back_list), FALSE);

    /* Pack the main box */
    gtk_box_prepend(GTK_BOX(widgets->back_list), widgets->header_bar);

    /* Only one of these will be visible at a time */
    gtk_box_append(GTK_BOX(widgets->back_list),
                   widgets->scrolled_window_search);
    gtk_box_append(GTK_BOX(widgets->back_list), widgets->scrolled_window_entry);
    gtk_box_append(GTK_BOX(widgets->back_list), widgets->no_entry);
    gtk_box_append(GTK_BOX(widgets->back_list), widgets->no_match);
    gtk_box_append(GTK_BOX(widgets->back_list), widgets->confirm_vbox);

    gtk_box_append(GTK_BOX(widgets->back_list), widgets->clear_all);

    gtk_widget_set_visible(widgets->no_match, FALSE);
    gtk_widget_set_visible(widgets->scrolled_window_search, FALSE);
    gtk_widget_set_visible(widgets->confirm_vbox, FALSE);

    if (options.no_csd)
    {
        gtk_widget_set_visible(widgets->close_window, FALSE);
    }

    if (total_sources)
    {
        gtk_widget_set_visible(widgets->no_entry, FALSE);
        widgets->visible = widgets->scrolled_window_entry;
    }
    else
    {
        gtk_widget_set_visible(widgets->scrolled_window_entry, FALSE);
        widgets->visible = widgets->no_entry;
    }

    gtk_window_set_child(GTK_WINDOW(widgets->window), widgets->back_list);
    gtk_window_present(GTK_WINDOW(widgets->window));
}

int main(int argc, char *argv[])
{
    GtkApplication *app = gtk_application_new("com.github.artsymacaw.kaprica",
                                              G_APPLICATION_DEFAULT_FLAGS);
    g_application_add_main_option_entries(G_APPLICATION(app), entries);

    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

    g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
}
